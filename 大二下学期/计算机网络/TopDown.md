# 计算机网络-自顶向下方法

[toc]

## 网络层

### 数据平面

#### 路由器

如P307

一个路由器有多个接口，每个LAN口一个地址。普通家用路由器一般是内网外网各一套mac和ip地址。

#### NAT转换表

P226

对于路由器，内网IP和外网IP之间的转换就需要NAT转换表。（该章后面有例题）

### 控制平面

#### 名词解释

+ 开销：图（图论里的图）上的权值
+ 最低开销路径：最短路径
+ SDN：软件定义网络，通过软件对路由选择算法等等进行控制P201

#### LS算法（Link State链路状态算法）

又称集中式路由选择算法

特点：具有全局状态信息

##### Dijkstra算法

![pic1](Pics\pic1.jpg)  

![pic2](Pics\pic2.jpg) 

![pic3](Pics\pic3.png) 

![pic4](Pics\pic4.png) 

*D(v)：*源点到v点的当前路径长度

*p(v)：*源点到v点的上一个节点

$N'$：已经确定找到的最短路径，就是每轮选一个最短，选出来的那个

大概就是每轮找一个最小的路径出来，然后基于最小的路径的这个节点更新它周围的节点（周围的节点可能之前也更新过，此次更新可能会使周围节点的最短路径变短，也要更新）

##### LS算法的振荡

教材P247，P248

大概就是每次都用LS算法选择最短路径（实际中是链路开销最小，某条链路拥塞程度最小），导致下一次很多路由器都选择这条链路，从而导致这条拥塞小的链路又变得拥塞，称之为振荡。

可以使得让路由器运行LS算法的时间随机化来解决，这样就不是随时每个路由器都在运行LS。

#### DV算法（距离向量算法）

又称分散式路由选择算法

特点：分布式的，不具有全局状态信息



*v*：x节点的所有邻接点

$d_x(y)$：从节点x到节点y的最低开销路径

*c(x,v)*：x到v的权值

$d_v(y)$：从节点v到节点y的最低开销路径

距离向量$D_x$：x的所有$d_x(y)$的集合

x到y的距离向量$D_x(y)$：从节点x到节点y的最低开销路径（跟$d_x(y)$很像，就是大写一下）



Bellman-Ford方程：
$$
d_x(y) = min_v\{  c(x,v) + d_v(y)  \}
$$


算法概括：采用一种递归的思想，$min_v$是对于x的所有邻接点而言的，就是x到y的距离等于x到所有邻接点的距离和邻接点到y的距离之和中最小的那一个。当x的$D_x$被更新了，那么它向它所有的邻接点都要发一个它的$D_x$，继而让邻接点更新





每个节点x存储的路由信息

1. 到x的所有邻接点v的开销c(x,v)
2. x到所有目的节点y的开销（估计值）$d_x(y)$
3. 所有邻接点v到y的开销（估计值）$d_v(y)$



P251：一个路由选择表更新的例子

P252：路由选择环路（两个节点来回互相更新）



一个小结：

![pic5](Pics\pic5.png) 



#### DV算法链路故障与毒性逆转

P252

#### AS（自治系统）

路由管理面对的问题

+ 规模：规模太大不好管理，应该切块
+ 管理自治：各个ISP通常选择自己希望的路由选择算法来运行路由器

所以需要AS（自治系统）将路由器组织成一个个的小系统



#### RIP（Routing Information Protocol）

RIP是一种AS内部的路由选择协议

使用DV算法

+ DV每隔30秒和邻居交换DV
+ 每个通告包括：最多25个目标子网
+ 毒性逆转：P253，防止路由选择环路使得两个节点来回互相循环更新的方案



#### OSPF（开放最短路优先）

OSPF是一种AS内部的路由选择协议

使用LS算法

+ LS 分组在网络中（一个AS内部）分发
+ 全局网络拓扑、代价在每一个节点中都保持
+ 路由计算采用Dijkstra算法

![pic6](Pics\pic6.png) 



#### 静态路由，RIP动态路由，OSPF动态路由

1. 静态路由

静态路由是手动配置的路由，管理员需要**手动输入路由信息**，例如目标网络地址、下一跳地址等。静态路由适用于网络规模较小、网络拓扑稳定不变的情况。静态路由的优点是易于配置，不需要消耗过多的网络资源；缺点是不够灵活，当网络拓扑发生变化时需要手动修改路由。

 

2. RIP动态路由

RIP（Routing Information Protocol）是一种基于距离向量的路由协议，采用**Bellman-Ford算法（DV算法）**计算最短路径。RIP将路由信息广播到整个网络中，每个路由器都可以通过接收相邻路由器广播的路由信息，更新自己的路由表。RIP适用于中小型网络，但在大型网络中会出现路由表收敛时间长、网络资源消耗大等问题。

 

3. OSPF动态路由

OSPF（Open Shortest Path First）是一种基于链路状态的路由协议，采用**Dijkstra算法**计算最短路径。OSPF通过交换链路状态信息（Link State Advertisement，LSA）来构建网络拓扑，每个路由器都可以根据链路状态信息计算出整个网络的最短路径。OSPF适用于大型复杂网络，能够快速适应网络拓扑的变化，但需要消耗大量的计算和存储资源。

 

综上，静态路由适用于小型网络拓扑不变的情况，RIP动态路由适用于中小型网络，OSPF动态路由适用于大型复杂网络。



#### BGP（边界网关协议）

BGP是AS之间的路由选择协议

##### 网关路由器和内部路由器

![pic7](Pics\pic7.png) 

1c：网关路由器（和其它AS有连接）

1b：内部路由器（和其它AS无连接）

##### eBGP/iBGP

eBGP: 从相邻的AS那里获得子网可达信息（外部）

iBGP: 将获得的子网可达信息传遍到AS内部的所有路由器（内部）

BGP通信报文：P257

##### 判别路由器从哪里学习前缀x

P257

P280中的P14

前缀x：某个AS内部的一个前缀为x的子网，通过BGP连接来在AS内部，AS之间发送报文来说明通过怎样的路径可达这个子网

学习到前缀x这种，都是通过BGP连接发送报文来说通过哪些AS可达前缀为x的子网

##### 热土豆路由选择

选择AS内代价最小的路径，发到下一个AS去（像热土豆一样烫，赶紧传给下一个AS）

这里到2a只要201，到2c最少都是263，所以选2a（虽然AS跳数增多）

![pic8](Pics\pic8.png) 

#### 路由选择策略

P262

接入ISP：W,Y那种

多宿接入ISP：X那种

就是防止B，C这种来抢占X的流量，所以X对B说不可达其它地方

P281中P17有题





#### SDN（软件定义网络）

路由选择设备仅执行转发，远程控制器计算并分发转发表

可以看P202

## 链路层

### 链路层提供的服务

+ 成帧

  将从网络层来的信息封装进帧，一个帧由一个数据字段和首部字段构成。

+ 链路接入

+ 可靠交付

+ 差错检测和纠正

  看P287

### 链路层在何处实现

主体在网络适配器（也叫网络接口卡/NIC/网卡）实现

部分在CPU中的软件实现

### 错误检验

EDC（差错检测和纠正位）

#### 比特模式

P331中P1

如比特模式1110 0110 1001 1101是一种比特模式

（实际上就是一串数据，像P291一样）

#### 最小长度检验和

最小长度检验和（Minimum Length Checksum）是一种数据校验方式，用于检查数据传输过程中是否出现错误。在最小长度检验和中，数据被分成若干个固定长度的块，在每个块的结尾处添加一个校验和，以检查该块数据是否传输正确。



如对于比特模式1110 0110 1001 1101，那么按最小长度检验和的方式，将比特模式如此划分后，采用二维偶校验方法

| 1    | 1    | 1    | 0    | 1    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 1    | 0    | 0    |
| 1    | 0    | 0    | 1    | 0    |
| 1    | 1    | 0    | 1    | 1    |
| 1    | 1    | 0    | 0    | 0    |

最后一列和最后一行为校验位

#### 单比特奇偶校验

就一位校验码，只能防错了一位比特的情况

##### 奇校验码

8位数据位和1位校验位，共9个数据，其中1的个数必须为奇数
一般校验位可以由八位数据位直接相加取反（同样不考虑进位）
11001010的校验位a = **~**(1+1+0+0+1+0+1+0) = 1（十进制的4，二进制的100，只要最后一位0，然后取反为1）
所以发送数据时为110010101

##### 偶校验码

8位数据位和1位校验位，共9个数据，其中1的个数必须为偶数
一般校验位可以由八位数据位按照二进制方式直接相加（不考虑进位）得到
11001010的校验位a = (1+1+0+0+1+0+1+0) = 0
所以发送数据时为110010100

##### 判断校验码

在FPGA的verilog代码设计时，可以使用异或运算，将数据位进行异或运算（这里是指每一位都用异或符号相连得到的结果）之后，若是奇数个1，则其结果应该是1，若是偶数个1结果则结果是0
若是偶校验方式，将每一位依次与0异或，保持
若是奇校验方式，将每一位依次与1异或，取反
最终得到校验码

或者剑伟说的，直接看有几个1，奇数个1就是奇校验码，偶数个1就是偶校验码

#### 二维奇偶校验

如图出现了一位比特差错的情况，观察下行列，发现基本上每行都是偶数个1，所以是偶校验码

然后发现第二行1的数量不对，然后第二列1的数量也不对，所以问题出在第二行第二列相交的那个位上，给改成1

对于两个比特出错，只能检测不能纠正

![pic9](Pics\pic9.png) 

#### CRC（循环冗余校验）

P291

名词解释：

+ D：要传送的d比特的数据
+ R：用来校验的r个CRC校验比特
+ G：生成多项式，发送方和接收方提前协商的r+1（二进制位数为r+1）的比特模式，要求G的最高位为1



对于数据D发送方要选择r个附加比特R，将其附加到D上，形成d+r比特模式，用模2运算恰好能被G整除

![pic10](Pics\pic10.png) 发送方发的内容长这样，G是提前协商好了的，要凑个能被整除的

接受方用G去除接受到的这d+r个bits的数据，余数为0则正确，否则检测出错

在二进制计算中，乘以$2^k$就是左

移k位，所以D附加上R后就是$D\cdot2^r$，然后需要按位异或（XOR）R，注意是最后r位对R进行按位异或，因为最后几位全是0，只要原来R中有1，则就会在D+R中变成1，所以这将R附加到D后完整的那一堆二进制变成了D$\cdot2^r$  XOR  R

所以最终目标是D$\cdot2^r$  XOR  R = nG，这样使得发出来的二进制能被G整除

R = $\frac{D\cdot2^r}{G}$ 的余数

（G是提前商量好的，随便定的，所以在D确定的情况下只需要知道R）

其实就是像十进制一样一直除，除到最后一位就行

![pic11](Pics\pic11.png) 

CRC能检测小于r+1的突发差错P292

#### 多路访问协议

多个站点一起发数据给接受方，多个帧的信号会在接收方处纠缠发生碰撞，导致信号混乱从而丢失帧。



##### 信道划分（如TDMA FDMA CDMA）

###### TDMA 时分复用

每个时间片按周期分给站点

![pic12](Pics\pic12.png) 

###### FDMA 频分复用

每个频段分给站点（就像无线广播FM一样，每个FM占一个频率）

![pic12](Pics\pic13.png) 

###### CDMA 码分多址

![pic12](Pics\pic14.png) 

##### 随机接入协议（ALOHA,CSMA）

###### 时隙ALOHA

P295

大概就是时分复用那种，但是每个时隙所有节点都可以用来发送

这样只有一个节点活跃的时候，就不会浪费时隙了。但是同样的，活跃的节点多了，碰撞的概率就增大了。

![pic15](Pics\pic15.png) 



![pic16](Pics\pic16.png) 



![pic17](Pics\pic17.png) 

###### 纯ALOHA

P297

似乎是有点问题，不好理解，但是不管了，背。

大概就是也不管时隙了，有帧就传。撞了之后概率重传（防止立刻再撞）

![pic18](Pics\pic18.png) 

![pic19](Pics\pic19.png) 

###### CSMA/CD载波侦听多路访问

CSMA: 在传输前先侦听信道

+ 如果侦听到信道空闲，传送整个帧
+ 如果侦听到信道忙，推迟传送
+ 侦听到碰撞之后立即停止（为什么已经侦听了还会碰撞？跟传播时延有关 **传播延迟（距离）决定了冲突的概率**  P299）
+ 停止随机时间量后再侦听

大量碰撞，停止的随机时间间隔长，少量碰撞，停止的随机时间间隔短 P300

随机等待时间采用二进制指数退避算法

![pic20](Pics\pic20.png) 

$d_{prop}$：传输/发送时延（将所有比特推向链路的时间，类比：准备好弹射的准备时间，加油站中的时间）

$d_{trans}$：传播时延（光速，类比：弹射，高速路）

![pic21](Pics\pic21.png) 

##### 轮流协议

P301

###### 轮询协议

一个主节点通知各个节点轮流传输

![pic22](Pics\pic22.png) 

###### 令牌传递协议

有令牌的节点才能传帧，令牌在节点之间一直传

![pic23](Pics\pic23.png) 

### MAC地址

P304

**链路层地址**又叫**MAC地址**，**LAN地址**，**物理地址**

MAC地址写死在网卡上的（其实也能用软件改），且独一无二。由6节16进制的数构成11-22-33-4C-5D-66这种样子。

当适配器向目的适配器发送一个帧时，该帧包含目的适配器的MAC地址。当某个适配器接受到一个帧时，就会检查这个帧的MAC地址是否跟自己的匹配，匹配就沿协议栈上传。

**IP地址用于实现互联网上的逻辑通信，而MAC地址则用于实现局域网内部的快速寻址和数据传输**。

个人看法：由于DHCP过段时间给每个主机换个IP，所以说尽管发包那些路由等等都是按IP来的，但是也只保证了能送到子网去，子网内的IP是经常更换的，所以说送到之后按MAC地址来找来送包才是最保险的。

#### ARP寻址

链路层和网络层之间的协议

P306

每台主机有一个ARP表，包含IP地址到MAC地址的映射，且这个表一般20分钟就要换一次。TTL代表过期时间，如P306的表。

ARP寻址流程：

![pic24](Pics\pic24.png) 

内部寻址的时候只知道IP不知道MAC地址需要在子网内部广播一下，子网内发现自己IP与广播寻求的IP相同的，则返回自己的MAC地址。P306

注意ARP只能在内部寻址，如P307-308。先根据之前的IP协议，发到路由器的对应接口去，此时是可以ARP寻址的，该帧的目的MAC地址是路由器的对应接口。之后路由选择到另一个接口，然后再重新封装一个帧，此时的MAC地址才是真的目标IP对应的目标MAC地址。

个人看法：只知道IP不知道MAC的情况也与IP与MAC分离的理由不冲突，毕竟已经设定好了要验证MAC是否与自己相同才沿着协议栈上传。IP是上层协议。已知MAC的情况应该是从发来的包中来得到的。
