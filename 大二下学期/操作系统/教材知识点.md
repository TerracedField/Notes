# OS

[toc]

## 第七章

### 设备无关性

用户在编制程序时使用的设备与实际使用的设备无关，用户程序中使用的是逻辑设备。

打印程序在那里，换什么牌子的打印机都能打印。

### spooling

SPOOLing：教材P181

SPOOLing系统接受OS来的打印任务，放到输出井（磁盘的一块区域）里，然后专门用于输出的输出进程从输出井里取出打印任务放到输出缓冲区（在内存中），然后按打印进度之类的（印完一个就下一个）交给打印机打印。别的进程发打印请求被SPOOLing系统接受后后就交给输出井。不用等打印结束进程才结束，扔进输出井就完事了。（word关闭后照样可以打印）

<img src="Pics\pic1.jpeg" alt="pic1" style="zoom:33%;" /> 

### 校验码

#### 取反

取反 （~） 属于按位逻辑运算符，属于一元运算符，其本质其实就是将数据每一位按位取反，**即将0变成1，将1变成0**

#### 奇校验码

8位数据位和1位校验位，共9个数据，其中1的个数必须为奇数
一般校验位可以由八位数据位直接相加取反（同样不考虑进位）
11001010的校验位a = **~**(1+1+0+0+1+0+1+0) = 1（十进制的4，二进制的100，只要最后一位0，然后取反为1）
所以发送数据时为110010101

#### 偶校验码

8位数据位和1位校验位，共9个数据，其中1的个数必须为偶数
一般校验位可以由八位数据位按照二进制方式直接相加（不考虑进位）得到
11001010的校验位a = (1+1+0+0+1+0+1+0) = 0
所以发送数据时为110010100

#### 判断校验码

在FPGA的verilog代码设计时，可以使用异或运算，将数据位进行异或运算（这里是指每一位都用异或符号相连得到的结果）之后，若是奇数个1，则其结果应该是1，若是偶数个1结果则结果是0
若是偶校验方式，将每一位依次与0异或，保持
若是奇校验方式，将每一位依次与1异或，取反
最终得到校验码

或者剑伟说的，直接看有几个1，奇数个1就是奇校验码，偶数个1就是偶校验码

### RAID

#### RAID0

直接一个磁盘全是用来存储的，但是不防数据丢失

#### RAID1

存储空间的一半用来开一个镜像，用来防数据丢失，损失一半的存储空间

#### RAID2

搞一个错误校验盘，一共n个盘，损失1个盘用来搞错误校验，也可以防数据丢失

#### 其它RAID

教材P192开始

### 磁盘硬件结构

教材P186



### 磁盘调度

#### FCFS：先来先调度

假设当前磁头地址：53

请求队列 = 98，183，37，122，14，124，65，67   （这些是要寻道的地址队列）

FCFS的访问顺序就纯按队列顺序来的，也是98，183，37，122，14，124，65，67

但是这样并不好，比如从53到98，中间可以访问65，67却直接跳过了

#### SSTF：最短寻道时间优先

假设当前磁头地址：53

请求队列 = 98，183，37，122，14，124，65，67   

那么会先访问离磁头地址：53最近的，比如一开始访问离53最近的65，然后是离65最近的67......

但是这样可能会使得磁头一直在某片区域寻找最小，有些离磁头远的但是先来的迟迟没有得到服务，所谓饥饿现象

#### SCAN：扫描（电梯）

向某一个方向（地址升序/降序）一直访问离它最短的要访问的地址，直到请求队列里面再也没有更大/更小的地址后改变方向，继续扫描（有点像电梯上下）

#### C-SCAN：循环扫描

规定只向某个方向（地址升序/降序）一直访问离它最短的要访问的地址，但是碰壁后直接闪现回另一端。比如访问到最大的地址后，直接闪现回最小的继续升序扫描。减小了扫描的周期，防止出现饥饿现象

#### N-Step-SCAN

其它算法可能出现“磁臂黏着”的情况，就是说某一小坨请求特别多，导致磁头一直停留在那一坨

N-Step-SCAN算法将请求队列分成若干个长度为N的队列，按FCFS先来先处理对这些小队列内部进行处理，然后按SCAN对这些小队列进行处理

#### FSCAN

将请求分成两个队列，一个是当前的I/O请求的队列，由SCAN算法进行处理

另外一个是处理第一个队列的过程中进来的新的请求，保存到一个队列中推迟到下一次扫描时处理 

#### 实例

如访问了56号柱面的请求后，现在在70号柱面上读信息，请求序列73	68	100	120	60	108	8	50

问：

1. SSTF算法访问序列
2. SCAN算法访问序列

答：

1. 70	68	73	60	50	8	100	108	120

   移动柱面数2 + 5 + 13... = 184

2. 因为上上个读56，现在读70，所以是按地址升序的

   70    73	100	108	120	68	60	50	8

## 第八章 文件管理

### 文件概念

文件是具有标识符（文件名）的一组相关信息的集合。

### 文件类型

P203开始

### 文件系统

**特点：按名存取** `剑伟莫名其妙念了两遍`

P208

文件系统的结构

+ 文件系统接口
+ 文件管理软件
+ 文件及其属性

### 文件操作

#### 打开文件

内存中有一张已打开文件的表

```c
int fd;
fd = open("xxx");
```

fd存的就是打开文件对应的那个编号

打开这样就直接操作内存中的文件的信息，比较高效方便

| 内存 |
| :--: |

|  fd  | 文件信息1 | 文件信息2 |
| :--: | :-------: | :-------: |
|  2   |  ......   |  ......   |
|  3   |  ......   |  ......   |
|  4   |   .....   |  ......   |

#### 关闭文件

关闭时就把这个fd从内存里的那张表里删除然后把相应的内容写回磁盘

### 文件目录

P210开始

#### FCB 文件控制块

文件目录：FCB的有序集合     （放磁盘中，可读到内存中）

FCB：

+ 文件的基本信息
+ 文件存取控制
+ 文件的使用信息

给一个文件名就可以通过查找文件目录来找到（按名存取）

#### 目录文件

放文件目录的文件

#### 一级目录

就把所有文件全放一个目录下面

这样就不允许文件重名

查找也很慢

#### 二级目录

P213

为每个用户开一个一级目录（UFD）

根目录（MFD）是每个用户的用户名和UFD

#### 多级目录

P214

就是差不多Windows这种

#### 目录的查询

P216

### 索引节点

概念：P211

查询：P216

目录文件里面放索引号和文件名

查找一个文件，在目录文件里面找到对应的文件名后根据对应的索引号到索引表里面根据索引号来访问索引节点，从而得到索引节点里面存的文件对应的一堆信息，这样查找文件时就不用频繁核对FCB里面的内容，基本只用核对一个文件名。

### 文件系统的实现

#### 分配单位

P221

可以按柱面、扇区、磁道等等来确定装一个文件的单位

教材按512B来作为单位（块）

#### 连续分配

类比数组

所有文件连续的装，不好增、删

#### 链接分配

类比链表

#### 索引分配

类比deque

一个map加一个链表

索引块：map

一个块里面用链表

#### 空闲存储空间管理

P224

