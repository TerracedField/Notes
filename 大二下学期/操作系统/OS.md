# OS

[toc]

## 第一章 引论

### OS的定义

操作系统：

定义：

从资源管理看：操作系统是`控制和管理计算机的软、硬件资源`，`合理地组织计算机的工作流程`，以及`方便用户`的`程序集合`。

从用户看：操作系统是配置在`计算机硬件上的第一层软件`，是`对硬件系统的第一次扩充`。

### OS的特征

+ 并发性：两个或两个以上的事物在同一时间间隔内发生
+ 共享性：系统中的软、硬件资源在其上的供多程序共同使用
  + 互斥共享：如打印机
  + 同时访问：如磁盘
+ 虚拟性：通过某种技术手段把一个**物理上**的实体，变成多个**逻辑上**的对应物（如CPU分时，每个时隙逻辑上当作一个CPU）
+ 不确定性：也称随机性，是指系统中各种事件的发生顺序是不确定的。

### OS的功能

操作系统的功能：

+ 进程管理
+ 存储管理
+ 设备管理
+ 文件管理

## 第二章 进程与线程

### 概念

进程：进程是具有独立功能的程序关于**某数据集合**上的一次**运行活动**，是**系统进行资源分配和调度的独立单位**。 

程序：程序是**指令**的**有序**集合。

进程控制块：

+ 为使多个程序能并发执行而为每个程序所配置的一个**专门的数据结构**，存放了用于描述进程情况和控制进程运行所需的全部信息。
+ 系统利用PCB来控制和管理进程，所以**PCB是系统感知进程存在的唯一标志**
+ 进程与PCB是一一对应的
+ PCB常驻内存

原语：不可中断的若干指令组成（例如创建进程原语，挂起原语）

线程（thread）是“进程”中某个单一顺序的控制流。也被称为轻量进程（lightweight processes）。

### 进程和程序的区别

![image-20230614145401282](Pics\pic2.png) 

程序和进程不是一一对应的关系

### 进程状态

P47

+ 就绪状态：已获得所有的必要资源，但未在处理机上运行，一般这种状态的进程是有个队列来排队等着被处理。
+ 运行状态：进程在CPU上执行
+ 阻塞状态：进程有关的资源未被满足，从就绪变到阻塞

![image-20230614150431576](Pics\pic3.png) 

其它：

P49

创建状态：进程的初始化，还不能运行

退出状态：进程结束，回收资源

挂起状态：将阻塞中的进程从内存换到外存

### PCB 进程控制块

P51

每个进程专门的数据结构

内容包括：

+ 程序：进程原来的代码
+ 数据：进程要用的数据
+ 栈：存进程的各种参数，调用地址等等

P53几个PCB队列

就对应之前几个状态的

就绪队列指针

阻塞队列指针

空闲队列指针（PCB可能是空的，可以分配给其它进程）

### 线程

可以共享进程中资源的一个轻量进程

好处：创建新线程耗时少，调度快等等



想象是进程占用了CPU，但是实际上是里面各种线程在分别占用

## 第三章 进程同步与通信

### 概念

临界资源：在某段时间内只允许一个进程使用的资源称为临界资源

临界区：在每个进程中访问临界资源的那段程序

### 信号量

P77

信号量定义：

```c
struct semaphore
{
    int value;
    struct PCB* queue;
}
```

包含一个指向进程（对信号量进行P,V操作的那个进程）PCB的指针和信号量的值

P操作：-1，进程占用一个信号量对应的资源

V操作：+1，进程释放一个信号量对应的资源

mutex：互斥锁，初始化为1

P80 mutex互斥锁一般要放在资源信号量里面

```c
P(empty);
P(mutex);
......
V(empty);
V(mutex);
```

书上有很多例题代码，尤其看下读者写者P81

### And信号量

P85，同时对两个以上信号量加锁

Swait(s1,s2...)：等于同时P多个信号量

Ssignal(s1,s2...)：等于同时V多个信号量

### 管程

P88

封装临界资源形成队列，一次只让一个达条件的进程进行访问，从而实现对临界资源的互斥。

cwait(c)：跟信号量的P操作有点像，如果管程里面某个临界资源c是0了，那么直接把这个进程挂在管子这个地方，把管程给其它进程用

csignal(c)：V操作，恢复卡在c这里的进程

### 进程通信

+ 共享内存：两个进程共享一个内存，读写一致
+ 管道通信：创建一个读端，一个写端，读端通过管道来读取写端的内容

## 第四章 调度与死锁

### 一些概念

调度分为抢占式和非抢占式（可剥夺和不可剥夺）

死锁：一组**竞争系统资源**或相互通信的进程间相互的**永久**阻塞。

### 进程调度算法

P103，看笔记本和PPT

FCFS先来先服务

SJF短作业优先

RR时间片轮转法

优先权调度......

### 死锁产生的必要条件

1. 互斥条件：访问的是临界资源
2. 请求和保持：请求了一个资源就必须占有，然后再去申请下一个资源
3. 不可抢占：占有了请求到的资源后，其它进程就不能抢占这个资源
4. 循环等待：形成环路，你请求我占有的，我请求你占有的

### 银行家算法

P115

很简单的

### 死锁检测资源分配图

P118

## 第五章 存储管理

### 一些概念

编译：用户**程序到**目标**模块**的过程。（目标模块的开始地址为0）

链接：将**编译好的**多个目标函数和需要的库函数**装配成**一个**完整的装入模块**。。（装入模块的开始地址为0）

装入：将装入模块，装入实际的地址空间，并且修改程序中跟地址有关的代码（重定位）。

重定位：完成装入模块中的逻辑地址到内存中的物理地址的转换。

### 编译和链接

#### 重定位

P122

##### 静态重定位

在**程序执行前**把程序中的逻辑地址修改为内存中的物理地址



缺点：

1. 程序要一片连续的内存空间
2. 重定位后程序不能在内存中移动

##### 动态重定位和重定位寄存器

动态重定位的实现需要重定位寄存器

重定位寄存器记录内存中模块的头地址

当执行到这条汇编的时候，发现涉及地址，那么直接把相对地址加上重定位寄存器中存的头地址就行

总的来说，动态重定位是直接把程序装入内存，执行时才改地址

#### 链接

P124

链接：将**编译好的**多个目标函数和需要的库函数**装配成**一个**完整的装入模块**。

##### 静态链接

装入内存前链接

优点：

简单

缺点：

修改目标模块很麻烦，要重新装入

##### 装入时动态链接

装入内存时发现需要哪些模块才链接

优点：

+ 便于修改和更新。 
+ 便于实现对目标模块的共享。 

##### 运行时动态链接

运行的时候发现有的模块还没装入才装入并链接

优点：

+ 加快程序的装入过程
+ 节省大量的内存空间 

### 连续内存分配

P125开始

碎片化问题严重，比如P1大小有100K，释放后P1的位置进来一个大小为99K的P2，那么就留下了1K碎片。

而且由于每个进程要装入连续空间，大进程基本只有等。

### 离散内存分配

#### 段式存储

P138

将程序按其本身的特性和含义(如main函数一个段)分成若干部分作为段。

每个进程创建时建立一个段表

##### 段表

| 段号 | 段长 | 段始址 |
| ---- | ---- | ------ |
| 0    | 15KB | 40KB   |
| 1    | 8KB  | 80KB   |
| 2    | 10KB | 100KB  |

##### 段式存储的逻辑地址

如对于一个装入模块，在执行到某一个需要调用其它地址时，需要动态重定位。此时那条汇编里写的地址是这样的段式地址：

| 段号 | 段内地址（段内偏移） |
| ---- | -------------------- |
| 2    | 500B                 |

就通过段号在段表里面找到对应的记录，首先比较段内地址（即段内偏移有没有越界超过段长），然后所要的物理地址就是段内地址加上段始址。



##### 段表寄存器

存放段表始址和段表长度。



进程切换后，重新载入段时地址有变化，段表也因此变化。

#### 页式存储

P130

##### 页框

把实际内存空间分成大小相同的若干个存储块，成为页框

##### 页面（程序页）

把进程的逻辑地址空间（一行一行的汇编）分成若干个与内存块大小相等的页

##### 页表

每个进程都有一张页表

| 页号 | 块号（页框号） |
| ---- | -------------- |

实现进程的逻辑页号到实际页框的映射

##### 页表寄存器

放页表的起始地址和页表长度

##### 根据页式存储的逻辑地址访问问题

看笔记本

##### 快表（TLB）

存放少量被频繁访问的页（也是对于当前按被执行的进程的专用表）

快表省了什么时间？看笔记本

##### 反置页表

反置页表将所有内存中的进程共享一个页表，从而减少了内存的占用。

通过进程标识符+页号来查询一个页框。

但是如果该进程的页不在反置页表里面，那么产生一个缺页中断，并进行调入。

##### 外部页表

跟反置页表相反，专门记录没在内存中的页。

#### 段页式存储

为每个进程分段，为每个段安排一个页表来分页

段表：记录每个段的页表始址和页表长度（访问页表始址以查询各个页表的内容）

页表：完成页号到页框的映射

### 进制和对应的字母

二进制是Binary，简写为B

八进制是Octal，简写为O

十进制为Decimal，简写为D

十六进制为Hexadecimal，简写为H

## 第六章 虚拟存储管理

### 一些概念

虚拟存储器的特征：

+ 离散性：作业不装入连续的存储空间，内存分配采用离散分配方式
+ 多次性：一个作业被分割，被多次调入内存。
+ 对换性：作业在运行过程中换进、换出内存。
+ 虚拟性：从逻辑上扩充了内存的容量。

### 局部性原理

![image-20230615194420964](Pics\pic4.png) 

![image-20230615194521262](Pics\pic5.png) 

### 虚拟存储器

#### 虚拟存储器的特征

+ 离散性：作业不装入连续的存储空间，内存分配采用离散分配方式
+ 多次性：一个作业被分割，被多次调入内存。
+ 对换性：作业在运行过程中换进、换出内存。
+ 虚拟性：从逻辑上扩充了内存的容量。

#### 虚拟存储器的功能

+ 请求调入：当访问不在内存中的页时请求调入那个页
+ 置换：内存已满时把不常用的页置换出去

### 页面置换算法

不要忘了如果页框为空，那么也算是缺页。

#### OPT

最佳置换

化身拉普拉斯妖预知后面要访问的页，然后每次将最长时间不会被访问到的页置换出去。

当然是不可能实现的，仅作为和其它算法对比用。

#### FIFO

先进先出

#### LRU

最近最久未使用置换

#### NRU，MRU

P155

看笔记本

### 全局置换和局部置换

对于多处理机（多道程序系统，可同时执行多个进程）



全局置换：对于进程A内存不够，可以淘汰其它进程的页

局部置换：只能淘汰自己的

全局置换很简单，但是剑伟说局部置换会好一点，公平

### 抖动现象

![image-20230615200548683](Pics\pic6.png) 

系统内进程增多=>每个进程的缺页率增大=>缺页率增大到一定程度，进程总是等待调页完成=>CPU利用率降低=>进程进一步增多，缺页率更大 …

### 工作集

定义：某段时间间隔$\Delta$内进程实际要访问的页的集合

![image-20230615201648160](Pics\pic7.png) 

如图$\Delta$  = 10，WS(t1)就是在t1时刻，之前10次访问的页面集合。

局部置换时，局部分配的页框数量大小为工作集的大小就不会频繁缺页或页数过多造成浪费

每个一小段时间系统扫描计算WS，使得局部页框大小总是合适

### 基于页错误率（PFF）的分配帧

页错误率（PFF）如果大于设定的页错误率上限，那么就给这个局部分配加帧直到小于上限

### Belady异常

![image-20230615202534116](Pics\pic8.png) 

可能局部分配的帧越多，缺页率越高。

## 第七章 设备管理

### 设备分类

​	P165

+ 块设备：存储设备
+ 字符设备：负责I/O，用于数据的输入输出

### I/O控制方式

#### 程序直接控制方式

CPU一直问，搬完没（CPU一直等待字符搬运）

#### 中断控制方式

搬字节的时候让CPU干其它的。一次搬一个字节，搬完一个字节告诉CPU，产生一次中断。

#### DMA控制方式

一次搬一批

#### I/O通道控制方式（最好的I/O控制方式）

一次搬N批



### 设备无关性

用户在编制程序时使用的设备与实际使用的设备无关，用户程序中使用的是逻辑设备。

打印程序在那里，换什么牌子的打印机都能打印。

### spooling技术实现输入输出

SPOOLing：教材P181

SPOOLing系统接受OS来的打印任务，放到输出井（磁盘的一块区域）里，然后专门用于输出的输出进程从输出井里取出打印任务放到输出缓冲区（在内存中），然后按打印进度之类的（印完一个就下一个）交给打印机打印。别的进程发打印请求被SPOOLing系统接受后就交给输出井。不用等打印结束进程才结束，扔进输出井就完事了。（word关闭后照样可以打印）

<img src="Pics\pic1.jpeg" alt="pic1" style="zoom:33%;" /> 

### 校验码

#### 取反

取反 （~） 属于按位逻辑运算符，属于一元运算符，其本质其实就是将数据每一位按位取反，**即将0变成1，将1变成0**

#### 奇校验码

8位数据位和1位校验位，共9个数据，其中1的个数必须为奇数
一般校验位可以由八位数据位直接相加取反（同样不考虑进位）
11001010的校验位a = **~**(1+1+0+0+1+0+1+0) = 1（十进制的4，二进制的100，只要最后一位0，然后取反为1）
所以发送数据时为110010101

#### 偶校验码

8位数据位和1位校验位，共9个数据，其中1的个数必须为偶数
一般校验位可以由八位数据位按照二进制方式直接相加（不考虑进位）得到
11001010的校验位a = (1+1+0+0+1+0+1+0) = 0
所以发送数据时为110010100

#### 判断校验码

在FPGA的verilog代码设计时，可以使用异或运算，将数据位进行异或运算（这里是指每一位都用异或符号相连得到的结果）之后，若是奇数个1，则其结果应该是1，若是偶数个1结果则结果是0
若是偶校验方式，将每一位依次与0异或，保持
若是奇校验方式，将每一位依次与1异或，取反
最终得到校验码

或者剑伟说的，直接看有几个1，奇数个1就是奇校验码，偶数个1就是偶校验码

### RAID

#### RAID0

直接一个磁盘全是用来存储的，但是不防数据丢失

#### RAID1

存储空间的一半用来开一个镜像，用来防数据丢失，损失一半的存储空间

#### RAID2

搞一个错误校验盘，一共n个盘，损失1个盘用来搞错误校验，也可以防数据丢失

#### 其它RAID

教材P192开始

### 磁盘硬件结构

教材P186



### 磁盘调度

#### FCFS：先来先调度

假设当前磁头地址：53

请求队列 = 98，183，37，122，14，124，65，67   （这些是要寻道的地址队列）

FCFS的访问顺序就纯按队列顺序来的，也是98，183，37，122，14，124，65，67

但是这样并不好，比如从53到98，中间可以访问65，67却直接跳过了

#### SSTF：最短寻道时间优先

假设当前磁头地址：53

请求队列 = 98，183，37，122，14，124，65，67   

那么会先访问离磁头地址：53最近的，比如一开始访问离53最近的65，然后是离65最近的67......

但是这样可能会使得磁头一直在某片区域寻找最小，有些离磁头远的但是先来的迟迟没有得到服务，所谓饥饿现象

#### SCAN：扫描（电梯）

向某一个方向（地址升序/降序）一直访问离它最短的要访问的地址，直到请求队列里面再也没有更大/更小的地址后改变方向，继续扫描（有点像电梯上下）

#### C-SCAN：循环扫描

规定只向某个方向（地址升序/降序）一直访问离它最短的要访问的地址，但是碰壁后直接闪现回另一端。比如访问到最大的地址后，直接闪现回最小的继续升序扫描。减小了扫描的周期，防止出现饥饿现象

#### N-Step-SCAN

其它算法可能出现“磁臂黏着”的情况，就是说某一小坨请求特别多，导致磁头一直停留在那一坨

N-Step-SCAN算法将请求队列分成若干个长度为N的队列，按FCFS先来先处理对这些小队列进行处理，然后按SCAN对这些小队列内部进行处理

#### FSCAN

将请求分成两个队列，一个是当前的I/O请求的队列，由SCAN算法进行处理

另外一个是处理第一个队列的过程中进来的新的请求，保存到一个队列中推迟到下一次扫描时处理 

#### 实例

如访问了56号柱面的请求后，现在在70号柱面上读信息，请求序列73	68	100	120	60	108	8	50

问：

1. SSTF算法访问序列
2. SCAN算法访问序列

答：

1. 70	68	73	60	50	8	100	108	120

   移动柱面数2 + 5 + 13... = 184

2. 因为上上个读56，现在读70，所以是按地址升序的

   70    73	100	108	120	68	60	50	8

## 第八章 文件管理

### 一些概念

文件：文件是具有标识符（文件名）的一组相关信息的集合。

FCB文件控制块：描述和控制文件的数据结构

+ 文件的基本信息
+ 文件存取控制
+ 文件的使用信息

文件系统的结构

+ 文件系统接口
+ 文件管理软件
+ 文件及其属性

### 文件类型

P203开始

按文件的用途分：

+ 系统文件
+ 用户文件
+ 库文件

按文件的性质分：

+ 普通文件
+ 目录文件
+ 特殊文件

按文件的存取属性分：

+ 可执行文件
+ 只读文件
+ 读/写文件

按文件数据的形式分：

+ 源文件
+ 目标文件
+ 可执行文件

### 文件系统

**特点：按名存取** `剑伟莫名其妙念了两遍`

P208

文件系统的结构

+ 文件系统接口
+ 文件管理软件
+ 文件及其属性

![image-20230615210941279](Pics\pic9.png) 



### 文件操作

#### 打开文件

内存中有一张已打开文件的表

```c
int fd;
fd = open("xxx");
```

fd存的就是打开文件对应的那个编号

打开这样就直接操作内存中的文件的信息，比较高效方便

| 内存 |
| :--: |

|  fd  | 文件信息1 | 文件信息2 |
| :--: | :-------: | :-------: |
|  2   |  ......   |  ......   |
|  3   |  ......   |  ......   |
|  4   |   .....   |  ......   |

#### 关闭文件

关闭时就把这个fd从内存里的那张表里删除然后把相应的内容写回磁盘

### 文件目录

P210开始

文件目录：FCB的有序集合（放磁盘中，可读到内存中）

#### FCB 文件控制块

FCB：

+ 文件的基本信息
+ 文件存取控制
+ 文件的使用信息

给一个文件名就可以通过查找文件目录来找到（按名存取）

#### 目录文件

放文件目录的文件

#### 一级目录

就把所有文件全放一个目录下面

这样就不允许文件重名

查找也很慢

#### 二级目录

P213

为每个用户开一个一级目录（UFD）

根目录（MFD）是每个用户的用户名和UFD

#### 多级目录

P214

就是差不多Windows这种

#### 目录的查询

P216

### 索引节点

概念和索引节点包含的内容：P211

查询：P216

目录文件里面放索引号和文件名

查找一个文件，在目录文件里面找到对应的文件名后根据对应的索引号到索引表里面根据索引号来访问索引节点，从而得到索引节点里面存的文件对应的一堆信息，这样查找文件时就不用频繁核对FCB里面的内容，基本只用核对一个文件名。

### 文件系统的实现

#### 分配单位

P221

可以按柱面、扇区、磁道等等来确定装一个文件的单位

教材按512B来作为单位（块）

#### 连续分配

类比数组

一个文件所有的信息都连续的装，不好增、删

#### 链接分配

类比链表

#### 索引分配

类比deque

一个map加一个链表

索引块：map

一个块里面用链表

#### 空闲存储空间管理

P224

最好的：成组链表法

###  文件权限

Linux下权限的属组有 拥有者 、群组 、其它组( u、 g 、o)三种。

Linux下文件的权限类型一般包括读，写，执行。对应字母为 r、w、x。

即我们可以用用三个8进制数字分别表示 拥有者 、群组 、其它组( u、 g 、o)的权限详情，并用chmod直接加三个8进制数字的方式直接改变文件权限。语法格式为 ：

```
chmod 777 file  (等价于  chmod u=rwx,g=rwx,o=rwx file 或  chmod a=rwx file)
```

在这种使用方式中，首先我们需要了解数字如何表示权限。 首先，我们规定 数字 4 、2 和 1表示读、写、执行权限（具体原因可见下节权限详解内容），即 r=4，w=2，x=1 。此时其他的权限组合也可以用其他的八进制数字表示出来，如： rwx = 4 + 2 + 1 = 7，rw = 4 + 2 = 6，rx = 4 +1 = 5

```
    -rw------- (600)      只有拥有者有读写权限。
    -rw-r--r-- (644)      只有拥有者有读写权限；而属组用户和其他用户只有读权限。
    -rwx------ (700)     只有拥有者有读、写、执行权限。
    -rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。
    -rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。
    -rw-rw-rw- (666)   所有用户都有文件读、写权限。
    -rwxrwxrwx (777)  所有用户都有读、写、执行权限。
```

