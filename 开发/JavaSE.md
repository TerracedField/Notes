[toc]

## 变量

### 进制

java7之后的特性

![image-20241115193455227](./assets/image-20241115193455227.png) 

### 变量范围

![image-20241115194101330](./assets/image-20241115194101330.png) 

### 驼峰命名

![image-20241115194306354](./assets/image-20241115194306354.png) 

### 引用数据类型

![image-20241118153626102](./assets/image-20241118153626102.png) 

变量存放的不是栈中的值，而是指向堆中的地址，那么就是引用数据

![image-20241118153732187](./assets/image-20241118153732187.png) 



## 数组

### 数组的静态初始化

![image-20241116200216624](./assets/image-20241116200216624.png) 



![image-20241116200248387](./assets/image-20241116200248387.png) 

### 数组的动态初始化

![image-20241116201445776](./assets/image-20241116201445776.png) 

虚拟机会给出arr的默认初始化值

![image-20241116201729512](./assets/image-20241116201729512.png) 



### 地址

```java
int [] a1 = {1,2,3,4,5,6,7,8,9};
System.out.println(a1);
```

```
[I@b4c966a
```

I:int类型

@是at

后面是数组地址值

### 获取长度

```java
arr.length
```

### 数组内存

![image-20241116203615244](./assets/image-20241116203615244.png) 



![image-20241116203726345](./assets/image-20241116203726345.png) 

两个指向同一空间

![image-20241116204329690](./assets/image-20241116204329690.png)

### 二维数组

![image-20241118154539853](./assets/image-20241118154539853.png) 

内存：

![image-20241118154645759](./assets/image-20241118154645759.png) 







 



## 字符串

### 制表符

![image-20241115192714473](./assets/image-20241115192714473.png)

### 加号拼接

![image-20241116184039189](./assets/image-20241116184039189.png) 

### String初始化

![image-20241118193831314](./assets/image-20241118193831314.png) 



### 串池StringTable

![image-20241118193739549](./assets/image-20241118193739549.png) 

专门保存直接赋值类型的String，在堆中

两个String都是直接赋值的话会指向串池中同一个地址，节约了内存空间

### new出来的String

![image-20241118194026748](./assets/image-20241118194026748.png) 

### 字符串比较

==是比较引用地址

用equals完全地比较

用equalsIgnoreCase忽略大小写比较（验证码）

### 遍历快捷键

![image-20241118195226079](./assets/image-20241118195226079.png) 

IDEA中.length().fori

### 返回索引对应字符

```java
String str = "123a";
char c = str.CharAt(3);
```

c的值是a

### StringBuilder

提高字符串操作效率

![image-20241118200502894](./assets/image-20241118200502894.png) 

普通的s6的计算逻辑是先把s1和s2拼成临时的，然后占掉一块内存，又去和剩下的拼

![image-20241118200713980](./assets/image-20241118200713980.png) 

StringBuilder直接在容器内操作

方法：

![image-20241118201123533](./assets/image-20241118201123533.png) 



### subString

```java
public String substring(int beginIndex)

public String substring(int beginIndex, int endIndex)
```

### StringJoiner

![image-20241118204942734](./assets/image-20241118204942734.png) 

可以指定间隔、开始、结束符号

### 字符串拼接底层逻辑

三个全是串池的：

![image-20241118210459727](./assets/image-20241118210459727.png) 

有变量参与拼接：

JDK自动搞出StringBuilder然后append得来

![image-20241118210307182](./assets/image-20241118210307182.png) 

### 字符串扩容底层原理

![image-20241118213300520](./assets/image-20241118213300520.png)





### 隐式转换/强制转换

#### 隐式转换

![image-20241116182859073](./assets/image-20241116182859073.png) 

取值范围小的直接给取值范围大的

![image-20241116182948480](./assets/image-20241116182948480.png) 

![image-20241116183300962](./assets/image-20241116183300962.png)

对于规则2：

![image-20241116183746144](./assets/image-20241116183746144.png)  

#### 强制转换

 ![image-20241116183524754](./assets/image-20241116183524754.png) 

直接把大范围赋给小范围会报错



## 包装类

![image-20241118222627774](./assets/image-20241118222627774.png)



## ArrayList

自动扩容

只能存引用数据类型，不能存int等基本数据类型，但是Integer可以

### 方法

![image-20241118221433514](./assets/image-20241118221433514.png) 

E：泛型

```java
ArrayList<String> list = new ArrayList<>();
```

后面这个泛型可以省略不写

### 快捷键遍历

```java
ArrayList<String> list = new ArrayList<>();

list.fori
```

直接遍历出现

```java
for (int i = 0; i < list.size(); i++) {}
```



 







## 运算符

### 逻辑运算符

![image-20241116184908905](./assets/image-20241116184908905.png) 

Java中只有一个符号也可以判断

### 短路逻辑运算符

![image-20241116185312046](./assets/image-20241116185312046.png) 

把&改成&&

把|改成||

这样就会先判断左边，如果左边已经达成true或false的条件就短路，跳过右边

### 三目运算符

![image-20241116185715019](./assets/image-20241116185715019.png)

### ==比较基本数据类型和引用数据类型

![image-20241118194140722](./assets/image-20241118194140722.png) 

![image-20241118194215042](./assets/image-20241118194215042.png) 

 

## 流程控制

### switch

![image-20241116190238537](./assets/image-20241116190238537.png) 

也可以是字符串等

![image-20241116191006603](./assets/image-20241116191006603.png) 

#### default

![image-20241116191123611](./assets/image-20241116191123611.png) 

#### case穿透

![image-20241116191240912](./assets/image-20241116191240912.png) 

![image-20241116191205956](./assets/image-20241116191205956.png) 

不加break全执行

#### jdk12新特性

![image-20241116191342295](./assets/image-20241116191342295.png) 

指针+大括号代替break

可以省略

![image-20241116191443374](./assets/image-20241116191443374.png) 







## 输入

### 输入int

![image-20241115194628473](./assets/image-20241115194628473.png) 





## 方法

### 形参、实参

![image-20241118151544575](./assets/image-20241118151544575.png) 



### 重载

![image-20241118152149863](./assets/image-20241118152149863.png) 

功能一样的方法可以取一样的方法名，但是形参要不一样



### 值传递

![image-20241118154303013](./assets/image-20241118154303013.png) 

传递基本数据类型时，传递的是真实的数据，形参的改变，不影响实际参数的值

![image-20241118154359377](./assets/image-20241118154359377.png) 

传递引用数据类型时，传递的是地址值，形参的改变，影响实际参数的值 



## 面向对象

### JavaBean

![image-20241118155420484](./assets/image-20241118155420484.png) 

### 权限修饰符

private：这种变量只能在类内部访问

| 修饰符    | 同一个类中 | 同一个包中其他类 | 不同包下的子类 | 不同包下的无关类 |
| --------- | ---------- | ---------------- | -------------- | ---------------- |
| private   | √          |                  |                |                  |
| 空着不写  | √          | √                |                |                  |
| protected | √          | √                | √              |                  |
| public    | √          | √                | √              | √                |



### 就近原则

<img src="./assets/image-20241118162528514.png" alt="image-20241118162528514" style="zoom: 50%;" /> 



### this关键字

指向对象自己



### 构造方法

![image-20241118162805382](./assets/image-20241118162805382.png) 

如果没有定义构造方法， 系统将给出一个默认的无参数构造方法

如果定义了构造方法，系统将不再提供默认的构造方法

推荐无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法



### 标准JavaBean

包含

1. private的各种属性
2. 属性对应的get、set方法
3. 有参构造器
4. 无参构造器

#### 快捷键

IDEA里面，对着其中一个属性用alt + insert

![image-20241118163349508](./assets/image-20241118163349508.png) 

选constructor

![image-20241118163404006](./assets/image-20241118163404006.png) 

属性全选然后OK，就是有参构造器

选select none就是无参构造器



选getter and setter就是全生成对应的get、set方法

#### PTG

下了PTG插件后直接空白处右键就可以找选项生成

![image-20241118164317768](./assets/image-20241118164317768.png) 

### 对象内存图

![image-20241118165024011](./assets/image-20241118165024011.png) 

方法放栈，new出的在堆

![image-20241118170002360](./assets/image-20241118170002360.png) 

就是把main加载进来后逐个执行，遇到方法就入栈，先执行栈顶的

![image-20241118170652254](./assets/image-20241118170652254.png) 

this的指向，哪个对象调用指向哪个



### 成员变量、局部变量

![image-20241118170948170](./assets/image-20241118170948170.png) 

一个放堆一个放栈

### 构造代码块



```java
public class Student {
    private String name;
    private int age;

    // 构造代码块
    // 1. 写在成员位置的代码块
    // 2. 作用：可以把多个构造方法中重复的代码抽取出来
    // 3. 执行时机：我们在创建本类对象的时候会先执行构造代码块再执行构造方法
    {
        System.out.println("开始创建对象了");
    }

    public Student() {
        // 默认构造方法
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

这段代码定义了一个`Student`类，其中包含两个私有成员变量`name`和`age`。类中还包含了一个构造代码块，它在创建对象时首先执行，用于打印一条消息。此外，类中定义了两个构造方法：一个是无参构造方法，另一个是带有`name`和`age`参数的构造方法，后者用于初始化对象的`name`和`age`属性。

### 静态代码块

![image-20241125211447418](./assets/image-20241125211447418.png)

只随着类的加载而加载

### 工具类

![image-20241125162052081](./assets/image-20241125162052081.png) 

用private修饰构造函数，防止这个对象被创建

类中有静态方法，外部直接调用静态方法即可



### static静态变量

![image-20241118233938929](./assets/image-20241118233938929.png) 

只要一次设置静态变量，后面所有该类的对象的对应静态变量都一样

![image-20241118234446830](./assets/image-20241118234446830.png) 

存在于堆空间，类加载就出现，比对象先出现

### static静态方法

![image-20241125161833369](./assets/image-20241125161833369.png)

### static注意

![image-20241125162653838](./assets/image-20241125162653838.png) 

### 继承

![image-20241125163531028](./assets/image-20241125163531028.png) 

关键字：extends 

子类extends父类

Java只支持单继承，不能多继承

可以多层继承



子类可以继承的内容：

![image-20241125164607705](./assets/image-20241125164607705.png) 

直接用父类的private变量报错

![image-20241125165054311](./assets/image-20241125165054311.png) 





#### 虚方法表

![image-20241125165337163](./assets/image-20241125165337163.png) 

子类调用父类方法理论上是逐级往上找的，但是很费事，所以有虚方法表可以提高性能

虚方法是继承的时候，往下传的

![image-20241125165715605](./assets/image-20241125165715605.png) 

#### 重写

重写是重写父类的方法

区别于重载，重载是参数不一样的同名函数

![image-20241125170412734](./assets/image-20241125170412734.png) 

#### 调用父类构造

![image-20241125170908720](./assets/image-20241125170908720.png) 

### 多态

<img src="./assets/image-20241125184635480.png" alt="image-20241125184635480" style="zoom:50%;" /> 

同一个父类的对象，表现出的多种形态

就是多个对象去实现父类接口

然后接口参数为父类



#### 多态调用成员

- 变量调用：编译看左边，运行也看左边。
- 方法调用：编译看左边，运行看右边。

即左边代码，a.name输出“动物”

a.show()输出“Dog---show方法”

![image-20241125190504246](./assets/image-20241125190504246.png) 

#### 优势

多态的优势

- 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。

```java
Person p = new Student();
p.work(); // 业务逻辑发生改变时，后续代码无需修改
```

定义方法的时候，使用父类型作为参数,可以接收所有子类对象,体现多态的扩展性与便利

如：

![image-20241125191301558](./assets/image-20241125191301558.png) 

所有对象都能用Object这个态，其它的是基本数据类型

#### 弊端

不能用子类特殊功能

![image-20241125191952351](./assets/image-20241125191952351.png) 

解决：

![image-20241125192241196](./assets/image-20241125192241196.png) 

### instanceof

```java
a instanceof Dog
```

返回bool值，即a是不是Dog类型的对象

```java
// 新特性
// 先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d
// 如果不是，则不强转，结果直接是false
if(a instanceof Dog d){
    d.lookHome();
} else if(a instanceof Cat c){
    c.catchMouse();
} else {
    System.out.println("没有这个类型，无法转换");
}
```

### 抽象类

![image-20241128090844034](./assets/image-20241128090844034.png) 

抽象方法没有方法体，只能被继承实现

### 接口

![image-20241128101058724](./assets/image-20241128101058724.png) 

如：

![image-20241128101341431](./assets/image-20241128101341431.png) 

或者不加public abstract，java自动加上：

![image-20241128102050289](./assets/image-20241128102050289.png) 

成员变量是public static final修饰的：

![image-20241128101727705](./assets/image-20241128101727705.png) 

细节：

![image-20241128102339579](./assets/image-20241128102339579.png)

#### 新特性default

![image-20241128102956174](./assets/image-20241128102956174.png) 

如：

![image-20241128103215834](./assets/image-20241128103215834.png) 

实现类不必重写default方法：

![image-20241128103323746](./assets/image-20241128103323746.png) 

#### 接口的静态方法

![image-20241128103829529](./assets/image-20241128103829529.png) 

#### 接口的私有方法

默认方法调用private

![image-20241128104607490](./assets/image-20241128104607490.png) 

#### 适配器设计模式

首先是一个interface

![image-20241128112928588](./assets/image-20241128112928588.png) 

然后用一个抽象的adapter去实现

![image-20241128113049334](./assets/image-20241128113049334.png) 

然后去实现这个抽象类

![image-20241128113112407](./assets/image-20241128113112407.png)



### 内部类

engine依赖于car

还有例子如ArrayList的itr

![image-20241128113505007](./assets/image-20241128113505007.png) 

#### 外部类内部类互相访问

内部类可以直接访问外部类

![image-20241128113735751](./assets/image-20241128113735751.png) 

外部类访问内部类要创建对象

![image-20241128113833201](./assets/image-20241128113833201.png) 

#### 静态内部类

![image-20241128153533033](./assets/image-20241128153533033.png) 

#### 匿名内部类

![image-20241128160648905](./assets/image-20241128160648905.png) 

没有名字的类实现一个接口

![image-20241128160640247](./assets/image-20241128160640247.png) 

实际上是匿名内部类的对象

![image-20241128160740866](./assets/image-20241128160740866.png) 

使用场景：

![image-20241128161045869](./assets/image-20241128161045869.png) 

method函数传参一个匿名类，就省去新建一个dog类的工作，有点像lambda



可以用匿名内部类实例化一个接口

![image-20241128161500537](./assets/image-20241128161500537.png) 







 

## 包

一般是公司域名反写\+对应的包名

com.baidu.test

![image-20241125201736974](./assets/image-20241125201736974.png)

### final关键字

final用在：

- 方法：表明该方法是最终方法，不能被重写。
- 类：表明该类是最终类，不能被继承。
- 变量：叫做常量，只能被赋值一次。

其它：

- final修饰的变量是基本类型：那么变量存储的数据值不能发生改变。
- final修饰的变量是引用类型：那么变量存储的地址值不能发生改变，对象内部的可以改变。

这段描述解释了在编程中使用`final`关键字修饰变量时的行为差异，取决于变量是基本数据类型还是引用类型。对于基本类型，`final`意味着一旦赋值，其值就不能被改变。而对于引用类型，`final`意味着引用本身（即变量存储的地址）不能改变，指向的对象内部的属性仍然可以被修改。

### native

![image-20241125202212889](./assets/image-20241125202212889.png) 

表示这个getClass方法是调用本地C或汇编等的，方法体不由Java语言实现

前面final表示这个方法不需要其它实现









## IDEA快捷键

### fori

```
arr.length.fori
```

生成i的for遍历

### getter setter constructor

对一个变量alt \+ insert

### 竖着多选

鼠标滚轮 \+ 拖曳

或者

alt \+ 鼠标左键

![image-20241118233621564](./assets/image-20241118233621564.png) 

### 报错快速解决

用鼠标点红色波浪线

alt\+enter

![image-20241128091511726](./assets/image-20241128091511726.png) 

点击直接转成抽象方法和抽象类

### 快速main类

psvm

### 选jdk版本

下一个高版本jdk可以切成低版本的

![image-20241128152921842](./assets/image-20241128152921842.png) 

