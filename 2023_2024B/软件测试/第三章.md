[toc]



## 有效无效等价类的划分

P46

注意如对10 < x < 100是有效，那么无效应该划为两个x <= 10和x >= 100

比如：

​	[软件测试 保险公司人寿保险保费计算程序的等价类_某保险公司的人寿保险的保费计算方式为-CSDN博客](https://blog.csdn.net/qq_39564555/article/details/105882671)

这个里面性别为英文字符的等价类就是无效的，里头整错了，其它可以抄

用例：

![P1](pics\P2.png)

**注意！！！！！！**

1. 年龄之类的要设上限
2. 无效输入要有对应提示（提示一定要明确，如值的范围应该是怎么怎么样）



测试用例数量：

最少：有效等价类中类别最多的那个的数量 + 无效等价类数量

最多：所有等价类（有效跟无效混起）的笛卡尔积

## 边界值

### 思想

基本思想：利用输入变量的最小值、略高于最小值、正常值、略低于最大值和最大值来设计测试用例。

### 边界值分析

对多变量边界值测试：

测试变量i：对除了变量i之外的其它变量取normal值，变量i依次测试

![P5](pics\P5.png) 

测试用例数：4n + 1（每个变量5种情况，但变量i的normal情况是公用的）

![P6](pics\P6.png) 



### 健壮性分析

边界值分析的扩展：除了五个边界值分析取值外，加上略超过最大值、略小于最小值的取值。

即利用输入变量的最小值、略高于最小值、正常值、略低于最大值和最大值，略超过最大值、略小于最小值来设计测试用例。

测试用例数：6n + 1（每个变量7种情况）

### 最坏情况测试

最坏情况测试是对每个变量，首先进行包含最小值、略高于最小值、正常值、略低于最大值和最大值五元素集合的测试,然后对这些集合进行笛卡儿积计算，以生成测试用例。

n变量产生$5^n$个测试用例，健壮性最坏情况产生$7^n$



### 结合等价类

**看作业3Q2，对输入和输出的等价类，进行边界值分析，然后根据边界值给出测试用例**

## 判定表

n对有限条目判定表，如果有n个条件，则产生$2^n$条规则。

**看作业3Q1，判定表可以包含等价类，用等价类给出判定表，最下面只有一个输出**

## 逻辑覆盖

### 语句覆盖

每个代码语句执行一次

缺点：比如if没有跟else，那么可能没有测试到if没有执行的情况

**(覆盖完流程图中所有的点)**

### 分支覆盖（判定覆盖）

判定覆盖法的基本思想是设计若干用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次，即判断真假值均曾被满足。

一个判定往往代表着程序的一个分支，所以判定覆盖也被称为分支覆盖。

**(覆盖完流程图中所有的边)**

### 条件覆盖

使每个判断中每个条件的可能取值至少满足一次。

判断中每个条件都至少一次true和false

缺点：可能一个判断有两个条件，两个条件各自一次true或false可能总的判断结果不变，还是测少了一些

### 分支条件覆盖（判定条件覆盖）

判定-条件覆盖是判定和条件覆盖设计方法的交集，即设计足够的测试用例，使得判断条件中的所有条件可能取值至少执行一次，同时，所有判断的可能结果至少执行一次。

每个判断执行一次，然后里面的条件各执行一次（区分条件组合，条件组合要每个条件排列组合的情况都出现一次，分支条件覆盖只要求每个条件出现一次）



判断中每个条件都至少一次true和false，并且还要保证每个判断都走过一遍(条件覆盖的基础上再判定覆盖，每个边都走一遍)



### 条件组合测试

对每个判断中的条件进行排列组合，让每个判断中各种条件的组合情况都至少出现一次。如判断A中有6个条件，那么A就有$2^6$种情况



条件组合覆盖的基本思想是设计足够的测试用例，使得判断中每个条件的所有可能至少出现一次，并且每个判断本身的判定结果也至少出现一次。

T2表示第2个条件True

| 组合编号 | 覆盖条件取值 | 判定条件取值 | 判定-条件组合     |
| -------- | ------------ | ------------ | ----------------- |
| 1        | T1，T2       | M=.T.        | a>0，b>0，M取真   |
| 2        | T1，F2       | M=.F.        | a>0，b<=0，M取假  |
| 3        | F1，T2       | M=.F.        | a<=0，b>0，M取假  |
| 4        | F1，F2       | M=.F.        | a<=0，b<=0，M取假 |
| 5        | T3，T4       | N=.T.        | a>1，c>1，N取真   |
| 6        | T3，F4       | N=.T.        | a>1，c<=1，N取真  |
| 7        | F3，T4       | N=.T.        | a<=1，c>1，N取真  |
| 8        | F3，F4       | N=.F.        | a<=1，c<=1，N取假 |

### 基本路径测试

[基本路径测试 - bmilk - 博客园 (cnblogs.com)](https://www.cnblogs.com/bmilk/p/14243817.html#:~:text=基本路径测试,定义：基本路径测试法又称独立路径测试，是在程序控制流图的基础上，通过分析控制结构的环路复杂性，导出基本可执行路径集合，从而设计出相应的测试用例的方法。 所谓基本路径是指程序中至少引进一条新的语句或一个新的条件的任一路径。)

[详解软件测试中基本路径测试法-CSDN博客](https://blog.csdn.net/qq_42944594/article/details/121929059)

圈复杂度：数出面上分了几块（**与独立的基路径数量相等**）

e：10（边的数量为10）

n：8（节点数量为8）

V(G) = e - n + 2p = 4 （p一般都 = 1）

V(G) = 区域数量(由节点、连线包围的区域，包括图形外部区域)

V(G) = 连线数量 - 节点数量 + 2

V(G) = 简单可预测节点数量 + 1



#### DD路径图

把一个程序转化成流程图，然后减去不影响圈复杂度的枝叶

#### 翻转节点法

1. 选择一个基路径（建议选择有尽可能多的判断节点的路径）；

2. 重新回溯（从正数开始回溯）该基线路径，依次“翻转”每个判断点；

3. 重复2，直到得到所有基路径。

就是先找到一个最长的基路径，遇到一个分支的时候就选择其中一个，直到走到出口，获得一个路径。然后回溯到第一个分支的那个节点，选择另一个节点，然后继续

步骤：

1. 把一个程序转化成流程图
2. 减去枝叶
3. 流程图方框全变成圆圈，然后给圆圈标号
4. 给边标号
5. 翻转节点法



## 定义组合测试

数据流测试：

[数据流测试_全定义覆盖准则和全定义使用覆盖准则-CSDN博客](https://blog.csdn.net/william_munch/article/details/85273730)

定义节点：定义变量的那个语句

使用节点：使用变量的语句

定义使用路径：一个程序中从定义节点到使用节点

定义清除路径：从定义v节点到使用v节点，其中没有其它定义v节点的路径

不是定义清除路径的定义使用路径是潜在问题



佣金问题locks处，循环前定义一次locks，循环中又定义locks，那么循环中定义的节点到其它使用都考虑为不是定义清清除

看PPT

### 程序片

S(v,n)：到n之前对v节点定义改变有作用的语句的集合，看PPT

S_3错的，S(locks,16) = {13, 14, 19, 20}

S_4错的，S(locks,19) = {13, 14, 19, 20}

S_2中包含14因为14可以控制是否进入循环，从而是否到19，从而是否会改变locks

而S_3不包含16因为16根本不影响locks
